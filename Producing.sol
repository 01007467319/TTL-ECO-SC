pragma solidity ^0.4.16;

//this defines an interface 'InterfaceImplProducing'
//providing function 'producing'.
interface interfaceProducing
{
    function producing(bytes32 block_header, uint k)  external returns(uint, uint, uint);
}


//the contract ‘producing’ will generate a committee consisting k arbitrators. 
//contract InterfaceImplProducing is interfaceProducing
contract Producing is interfaceProducing
{
    
    //defining current height number of the blockchain
    uint chain_height;
    
    //defining arbitrators signature array
    bytes32[11]  sign_value;
    
    //defining especial blocks generated by the arbitrators
    uint[11] number_block;
    
    
    //the priducting generates k arbitrators.
    //each arbitrator is randomly generated after the previous arbitrator was generated.
    //we use the number_block to represent the arbitrator,
    //since Solidity does not provide the application programme interface (API) of mapping
    //about the relation between the miner(arbitrator) and the block. 
    //subsituting signature algorithm with keccak256, 
    //since Solidity does not provide the API of deterministic digital signature.
    function producing(bytes32 block_header, uint k) external returns(uint, uint, uint)
    {
        
        bytes32 hash_block_header;
        uint h;

        for (uint i = 0; i < k; i ++)
        {
           if (i == 0)
           {
              hash_block_header = keccak256(block_header);         //hash current block header block_header
              hash_block_header = keccak256(block_header);         //hash current block header block_header
              h = uint(hash_block_header);                         //convert bytes32 to uint
              chain_height = block.number;                         //obtain current blockchain height
              number_block[i] = addmod(h, 0, chain_height);        //computing (h+0)%chain_height, obtaining one block number
              sign_value[i] = keccak256(this);                     //instituting signature algorithm DDSA with keccak256        
               
           }
           else
           {
              hash_block_header = keccak256(block_header ^ sign_value[i - 1]);   //hash current block header block_header and the (i-1)-th arbitrator signature value
              h = uint(hash_block_header);                                       //convert bytes32 to uint
              chain_height = block.number;                                       //obtain current blockchain height
              hash_block_header = block_header;
              number_block[i] = addmod(h, 0, chain_height);       //computing (h+0)%chain_height, obtaining one block number
              sign_value[i] = keccak256(block_header ^ sign_value[i - 1]);  //instituting signature algorithm with keccak256        
               
           }
        }
        
        //return some arbitrators selected randomly
        return (number_block[0], number_block[1], number_block[2]);
    }
    
}





